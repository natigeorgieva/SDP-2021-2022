#include <iostream>
#include <queue>
#include <string>


/**
	Функция, която проверява дали един символен низ се
	състои само от цифри

	@param[in] s Входния низ

	@returns   Връща true, ако е изпълнено условието, в
			   противен случай false
*/
bool isInteger(std::string s) {
	bool state = true;		///Флаг, с който означаваме дали текущия низ съдържа само цифри

	for (int i = 0; state && i < s.length(); i++) {
		if (!isdigit(s[i])) {		///Ако намерим символ различен от цифра сваляме флага
			state = false;
		}
	}

	return state;
}


/**
	Функция, която конвертира даден символен низ в целочислена стойност

	@param[in] s Входния низ

	@returns   Връща числото в символния низ като целочислена данна
*/
int toInteger(std::string s) {
	int num = 0; ///Текущото число

	for (int i = 0; i < s.length(); i++) {
		num = 10 * num + (s[i] - '0');	///Умножаваме текущото число с 10 и го събираме с текущата цифра
	}

	return num;

}


/**
	функция, която въвежда в реферирана опашка от цели числа,
	докато не се въведе нещо, което не е цяло число

	@param[in, out] q Подадена опашка, в която пълним цели числа

*/
void inputQueue(std::queue<int>& q) {
	std::string input;  ///Низ, в който пазим текущия вход от клавиатурата

	while(1) {
		std::cin >> input;		///Извличаме от потока низ

		if (isInteger(input)) {			///Ако извлечения низ е число
			q.push(toInteger(input));   ///Преобразуваме го в такова и го слагаме в опашката
		}
		else {							///В противен случай терминираме функцията
			return;
		}
	}
}


///Функция принтираща опашкана екрана. За по-подробно обяснение се консултирайте с
///решените примери от предишното упашнение
void outputQueue(std::queue<int> q) {

	while (!q.empty()) {
		std::cout << q.front() << " ";
		q.pop();
	}
}

/**
    Фунцкия, която проверява дали елементите в опашка са подредени в
    растящ ред, т.е. елемента, който седи на чело на опашката е по-малък
    от всички останали
*/
bool isAscending(std::queue<int> q){

    ///Докато в опашката има поне два елемента
    while(q.size()>=2){
        int temp = q.front(); ///Запазваем стойността на предния елемент
        q.pop();              ///и го премахваме

        if(q.front() < temp){ ///Ако текущия преден елемент е по-малък от предишния преден, значи не е в нарастващ ред
            return false;     ///Следователно ввръщаме false - не е подредена
        }
    }

    return true; ///Ако за цялата опашка не сме намерили противоречие то тя е продредена в растящ ред и връщаме true

}

/**
    Фунцкия, която по подадени две сортирани опашки в растящ ред връща трета опашка,
    която също е сортирана с елементите на подадените две.

    @param[in] q1, q2 Двете подадени опашки

    @returns Опашка, която е сортирана с елементите на q1 и q2

    @throws 1 Ако q1 не е сортирана растящо
    @throws 2 Ако q2 не е сортирана растящо
*/
std::queue<int> mergeQ(std::queue<int> q1, std::queue<int> q2){

    ///Тестов блок, в който проверяваме дали входа е коректен
    try{
        ///Ако някоя от двете опашки не е подредена възходящо хвърляме грешка, която ще хванем в catch блока
        if(!isAscending(q1))
        throw 1;
        if(!isAscending(q2))
        throw 2;
    }catch(int err){
        ///Ако има хвърлена грешка изписваме на екрана
        std::cout<<(err == 1 ? "First": "Second")<<" queue is not sorted!";
        throw; /// Предаваме кода на грешката на викащата функция
    }

    std::queue<int> result;

    ///Докато и в двете опашаки има елементи
    while(!q1.empty()&&!q2.empty()){
        ///Ако предния елемент в q2 е по-малък от предния елемент в q1
        if(q1.front() > q2.front()){
            result.push(q2.front()); ///Пъхаме предния елемент на q2 в резултатната опашка
            q2.pop();                ///Премахваме елемента от q2
        }
        ///В противен случай правим горните стъпки за q1
        else{
            result.push(q1.front());
            q1.pop();
        }
    }

    ///Сега ако някоя от двете опашки има елементи, ще се изпълни
    ///съответния цикъл и ше пъхне останалите елементи в резултатната опашка
    while(!q1.empty()){
        result.push(q1.front());
        q1.pop();
    }

    while(!q2.empty()){
        result.push(q2.front());
        q2.pop();
    }

    return result;

}

int main(){
    std::queue<int> q1, q2;
    inputQueue(q1);
    inputQueue(q2);

    outputQueue(mergeQ(q1, q2));
}
